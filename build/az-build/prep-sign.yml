steps:
  - task: PowerShell@2
    displayName: Generate Fake Sign Key (for delay signing)
    name: gen_delay_key
    inputs:
      targetType: 'inline'
      script: |
        # Write your PowerShell commands here.
        
        echo 'Generating Key'
        & 'C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.8 Tools\sn.exe' -k '$(Agent.TempDirectory)\fake.snk'
        
        echo 'Exctracting Publick Key'
        & 'C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.8 Tools\sn.exe' -p '$(Agent.TempDirectory)\fake.snk' '$(Agent.TempDirectory)\fake.publickey'
        
        echo 'Converting Publik Key to String'
        & 'C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.8 Tools\sn.exe' -q -tp '$(Agent.TempDirectory)\fake.publickey' | Out-File -Encoding ASCII -FilePath '$(Agent.TempDirectory)\fake.token'

        cat '$(Agent.TempDirectory)\fake.token'

  - task: Bash@3
    displayName: Exctract Sign Token (for InternalsVisibleTo)
    name: get_delay_key
    inputs:
      targetType: 'inline'
      script: |
        # This is needed because some PM in Azure Dev Ops beleives that presenting Windows paths to bash is 
        # you know it... "Not a bug" ... way to go JR PM at MSFT ... way to have no clue what your market is.
        function wslpath() { 
        echo "$1" | sed -e 's|\\|/|g' -e 's|^\([A-Za-z]\)\:/\(.*\)|/\L\1\E/\2|'
        }
        # Write your commands here
        
        echo 'Displaying PublicKey Text'
        cat "$(wslpath $AGENT_TEMPDIRECTORY)/fake.token"

        echo 'Striping content from publickey text'
        ls "$(wslpath $AGENT_TEMPDIRECTORY)/fake.token"

        ls "$(wslpath $AGENT_TEMPDIRECTORY)/fake.token" | xargs sed -i '/^\W*$/d' 
        ls "$(wslpath $AGENT_TEMPDIRECTORY)/fake.token" | xargs sed -i '/^Pub.*$/d' 

        echo 'after alteration'
        cat "$(wslpath $AGENT_TEMPDIRECTORY)/fake.token"

        cat "$(wslpath $AGENT_TEMPDIRECTORY)/fake.token" | tr -d '\r\n' > "$(wslpath $AGENT_TEMPDIRECTORY)/fake.hex"
        
        echo 'as one string'
        cat "$(wslpath $AGENT_TEMPDIRECTORY)/fake.hex"
        echo ''
        echo 'Setting Publickey variable'
        DS_PK=$(cat "$(wslpath $AGENT_TEMPDIRECTORY)/fake.hex")
        echo 'displaying publickey hex code'
        echo $DS_PK
        echo "##vso[task.setvariable variable=DS_PK]$DS_PK"
        echo "##vso[task.setvariable variable=DS_PK;isOutput=true]$DS_PK"

        ls "$AGENT_TEMPDIRECTORY"
        echo "Completed Script"

  - task: Bash@3
    displayName: 'Write the start of the sign.cs file'
    name: start_sign_cs_file
    inputs:
      targetType: 'inline'
      script: |
        # This is needed because some PM in Azure Dev Ops beleives that presenting Windows paths to bash is 
        # you know it... "Not a bug" ... way to go JR PM at MSFT ... way to have no clue what your market is.
        function wslpath() { 
          echo "$1" | sed -e 's|\\|/|g' -e 's|^\([A-Za-z]\)\:/\(.*\)|/\L\1\E/\2|'
        }
        # Insert Token data as C# String
        cat build/az-build/sign-start.cs > "$(wslpath $AGENT_TEMPDIRECTORY)/sign.cs"
        # End of Script

  - task: Bash@3
    displayName: 'Insert key data into sign.cs'
    name: insert_key_data
    inputs:
      targetType: 'inline'
      script: |
        # This is needed because some PM in Azure Dev Ops beleives that presenting Windows paths to bash is 
        # you know it... "Not a bug" ... way to go JR PM at MSFT ... way to have no clue what your market is.
        function wslpath() { 
          echo "$1" | sed -e 's|\\|/|g' -e 's|^\([A-Za-z]\)\:/\(.*\)|/\L\1\E/\2|'
        }
        # Insert Token data as C# String
        cat "$(wslpath $AGENT_TEMPDIRECTORY)/fake.token" | sed -E 's/^(.*)$/\"\1\" +/' >> "$(wslpath $AGENT_TEMPDIRECTORY)/sign.cs"
        # End of Script

  - task: Bash@3
    displayName: 'Write the end of the sign.cs file'
    name: end_sign_cs_file
    inputs:
      targetType: 'inline'
      script: |
        # This is needed because some PM in Azure Dev Ops beleives that presenting Windows paths to bash is 
        # you know it... "Not a bug" ... way to go JR PM at MSFT ... way to have no clue what your market is.
        function wslpath() { 
          echo "$1" | sed -e 's|\\|/|g' -e 's|^\([A-Za-z]\)\:/\(.*\)|/\L\1\E/\2|'
        }
        # Insert Token data as C# String
        cat build/az-build/sign-end.cs >> "$(wslpath $AGENT_TEMPDIRECTORY)/sign.cs"
        # End of Script

  - task: Bash@3
    displayName: 'Output sign.cs for diagnostics'
    name: output_sign_cs_file
    inputs:
      targetType: 'inline'
      script: |
        # This is needed because some PM in Azure Dev Ops beleives that presenting Windows paths to bash is 
        # you know it... "Not a bug" ... way to go JR PM at MSFT ... way to have no clue what your market is.
        function wslpath() { 
          echo "$1" | sed -e 's|\\|/|g' -e 's|^\([A-Za-z]\)\:/\(.*\)|/\L\1\E/\2|'
        }
        # Output Sign File
        cat "$(wslpath $AGENT_TEMPDIRECTORY)/sign.cs" 


  - task: eliostruyf.build-task.custom-build-task.file-creator@2
    displayName: 'Create sign.proj File'
    inputs:
      fileoverwrite: true
      filepath: '$(Build.SourcesDirectory)\\sign.proj'
      filecontent: |
        <Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
          <PropertyGroup>
            <AssemblyOriginatorKeyFile>$(Agent.TempDirectory)\fake.snk</AssemblyOriginatorKeyFile>
            <DelaySign>True</DelaySign>
          </PropertyGroup>

          <ItemGroup>
            <Compile Include="$(Agent.TempDirectory)\sign.cs" />
          </ItemGroup>
        </Project>

