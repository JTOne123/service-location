# ASP.NET Core (.NET Framework)
# Build and test ASP.NET Core projects targeting the full .NET Framework.
# Add steps that publish symbols, save build artifacts, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core

trigger:
- master

variables:
  solution: 'Landorphan.Ioc.ServiceLocation.sln'
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'

stages:
  - stage: win_build
    displayName: Windows Build
    dependsOn: 
    jobs:
    - job: setup
      displayName: Setup System for Code Signing
      dependsOn: []
      pool:
        vmImage: 'windows-latest'
      steps:
      - template: build/az-build/prep-env.yml
      - template: build/az-build/prep-sign.yml
      - template: build/az-build/alter-version.yml
      - template: build/az-build/alter-sign.yml

    # - job: system_diagnostics
    #   displayName: Output System diagnostics
    #   dependsOn: setup
    #   variables:
    #     LNDF_VER: $[ dependencies.setup.outputs['set_version.LNDF_VER'] ]
    #     LNDF_VER_FULL: $[ dependencies.setup.outputs['set_veersion_full.LNDF_VER_FULL'] ]
    #     DS_PK: $[ dependencies.setup.outputs['get_delay_key.DS_PK'] ]
    #   pool:
    #     vmImage: 'windows-latest'
    #   steps:
    #   - script: |
    #       echo Write your commands here
    #       mkdir "$(Build.BinariesDirectory)/raw-build"
    #       dir "$(Build.BinariesDirectory)/raw-build"
    #       set
          
    #       echo "%DS_PK%"
    #       echo ""
    #       echo "Build Version: %DS_VER$"
    #       echo "Full Build Version: %DS_VER_FULL%"
    #       echo ""
    #       echo "dotnet --list-runtimes"
    #       dotnet --list-runtimes
    #       echo ""
    #       echo ""
    #       echo "dotnet --list-sdks"
    #       dotnet --list-sdks
    #       echo ""
    #       echo ""
    #       echo Use the environment variables input below to pass secret variables to this script
    #     displayName: 'Display Environment Info & Setup'

    #   - script: error 

    #   # - task: eliostruyf.build-task.custom-build-task.file-creator@2
    #   #   displayName: 'Create sign.cs File'
    #   #   inputs:
    #   #     fileoverwrite: true
    #   #     filepath: '$(Build.SourcesDirectory)\sign.cs'
    #   #     filecontent: |
    #   #       using System.Reflection;
            
    #   #       [assembly:AssemblyKeyFileAttribute(@"$(Agent.TempDirectory)\Landorphan-Light.snk")]

    #   - task: DownloadSecureFile@1
    #     inputs:
    #       secureFile: 'Landorphan-Light.snk'

    #   - script: |
    #       echo Write your commands here

    #       dir %BUILD_SOURCESDIRECTORY%   
    #       dir %BUILD_BINARIESDIRECTORY%
    #       dir d:\a\_temp
    #       cat %BUILD_SOURCESDIRECTORY%\sign.cs
    #       dir "$(Agent.BuildDirectory)\d"
          
    #       echo Use the environment variables input below to pass secret variables to this script
    #     displayName: 'Display Directory Info'

    # - job: core_build
    #   displayName: Run the core build
    #   dependsOn: setup
    #   pool:
    #     vmImage: 'windows-latest'
    #   steps:
      - task: Bash@3
        inputs:
          targetType: 'inline'
          script: |
            # Write your commands here
            
            ls
            
      - task: NuGetToolInstaller@1
        displayName: Download most recent NuGet Tools

      - task: NuGetCommand@2
        inputs:
          restoreSolution: '$(solution)'

      - task: VSBuild@1
        displayName: 'Build solution **/Landorphan.Ioc.ServiceLocation.sln'
        inputs:
          solution: '**/Landorphan.Ioc.ServiceLocation.sln'
          platform: '$(BuildPlatform)'
          configuration: '$(BuildConfiguration)'
          
      - task: Bash@3
        displayName: 'Create list of output assemblies for code signing'
        inputs:
          targetType: 'inline'
          script: |
            # This is needed because some PM in Azure Dev Ops beleives that presenting Windows paths to bash is 
            # you know it... "Not a bug" ... way to go JR PM at MSFT ... way to have no clue what your market is.
            function wslpath() { 
              echo "$1" | sed -e 's|\\|/|g' -e 's|^\([A-Za-z]\)\:/\(.*\)|/\L\1\E/\2|'
            }
            function wslpath2 {
              while read data; do
                echo "$data" | sed -e 's|\\|/|g' -e 's|^\([A-Za-z]\)\:/\(.*\)|/\L\1\E/\2|' 
              done
            }
            
            # Locate all assemblies that need to be signed.
            find . -name '*.sign' | xargs cat | sed -E 's/.([\x20-\x7E]*)/\1/g' | sed 's/\\/\\\\/g' | echo "$(wslpath2 %)" > "$(wslpath $AGENT_TEMPDIRECTORY)/assemblies.sign"
            echo 'Located the following assemblies to sign'
            cat "$(wslpath $AGENT_TEMPDIRECTORY)/assemblies.sign"

      - task: AzureKeyVault@1
        displayName: 'Azure Key Vault: landorphan-build'
        inputs:
          azureSubscription: 'Landorphan Holdings (1286ed67-15ce-4500-899e-e79313d8329f)'
          KeyVaultName: 'landorphan-build'
          SecretsFilter: 'LandorphanKeyVaultKey'

      - task: Bash@3
        inputs:
          targetType: 'inline'
          script: |
            # This is needed because some PM in Azure Dev Ops beleives that presenting Windows paths to bash is 
            # you know it... "Not a bug" ... way to go JR PM at MSFT ... way to have no clue what your market is.
            function wslpath() { 
              echo "$1" | sed -e 's|\\|/|g' -e 's|^\([A-Za-z]\)\:/\(.*\)|/\L\1\E/\2|'
            }
            # Locate all assemblies that need to be signed.
            ls "$(wslpath $AGENT_BUILDDIRECTORY)/d"
            cat "$(wslpath $AGENT_TEMPDIRECTORY)/assemblies.sign" | head -n 1 | xargs -I % ls "%"

      - script: |
          echo Write your commands here
          
          %AGENT_BUILDDIRECTORY%\d\AzureSignTool.exe sign "%BUILD_SOURCESDIRECTORY%\bin\release\Landorphan.Ioc.ServiceLocation\net451\Landorphan.Ioc.ServiceLocation.dll" --file-digest sha256 --description-url "https://github.com/landorphan/service-location" --no-page-hashing --timestamp-rfc3161 http://timestamp.comodoca.com --timestamp-digest sha256 --azure-key-vault-url "https://landorphan-build.vault.azure.net/" --azure-key-vault-client-id "b32bbbae-55c3-4f5b-bf40-0292d349886f" --azure-key-vault-client-secret "$(LandorphanKeyVaultKey)" --azure-key-vault-certificate "Landorphan-LightWeight-CodeSign"
          
          %AGENT_BUILDDIRECTORY%\d\AzureSignTool.exe sign "%BUILD_SOURCESDIRECTORY%\bin\release\Landorphan.Ioc.ServiceLocation\netstandard2.0\Landorphan.Ioc.ServiceLocation.dll" --file-digest sha256 --description-url "https://github.com/landorphan/service-location" --no-page-hashing --timestamp-rfc3161 http://timestamp.comodoca.com --timestamp-digest sha256 --azure-key-vault-url "https://landorphan-build.vault.azure.net/" --azure-key-vault-client-id "b32bbbae-55c3-4f5b-bf40-0292d349886f" --azure-key-vault-client-secret "$(LandorphanKeyVaultKey)" --azure-key-vault-certificate "Landorphan-LightWeight-CodeSign"
          
          echo Use the environment variables input below to pass secret variables to this script
        displayName: 'ServiceLocation: Azure Code Sign copy'
        enabled: false


      - task: VSTest@2
        displayName: 'VsTest - testAssemblies'
        inputs:
          testAssemblyVer2: |
            **\$(BuildConfiguration)\**\*Tests.dll
            **\$(BuildConfiguration)\**\*Tests.*.dll
            !**\obj\**
          testFiltercriteria: '(TestCategory=Check-In|Check-In-Non-Ide)'
          codeCoverageEnabled: true
          platform: '$(BuildPlatform)'
          configuration: '$(BuildConfiguration)'
          diagnosticsEnabled: True
      
      - task: CopyFiles@2
        inputs:
          SourceFolder: '$(Agent.TempDirectory)'
          Contents: 'assemblies.sign'
          TargetFolder: '$(Build.ArtifactStagingDirectory)'

      - task: CopyFiles@2
        displayName: 'TEMP: Copy Files to: $(Build.ArtifactStagingDirectory)'
        inputs:
          SourceFolder: '$(system.defaultworkingdirectory)'
          Contents: '$(Build.SourcesDirectory)\**\bin\$(BuildConfiguration)\**'
          TargetFolder: '$(Build.ArtifactStagingDirectory)'


      - task: PublishBuildArtifacts@1
        inputs:
          PathtoPublish: '$(Build.ArtifactStagingDirectory)'
          ArtifactName: 'drop'
          publishLocation: 'Container'